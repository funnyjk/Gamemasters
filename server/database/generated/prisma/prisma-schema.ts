// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateGame {
  count: Int!
}

type AggregatePlayer {
  count: Int!
}

type AggregateScore {
  count: Int!
}

type AggregateSession {
  count: Int!
}

type AggregateTournament {
  count: Int!
}

type AggregateTournamentPlayer {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Game {
  id: ID!
  owner: User
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session!]
  name: String!
  bgg_id: String
  notes: String
}

type GameConnection {
  pageInfo: PageInfo!
  edges: [GameEdge]!
  aggregate: AggregateGame!
}

input GameCreateInput {
  id: ID
  owner: UserCreateOneWithoutGamesInput
  sessions: SessionCreateManyWithoutGameInput
  name: String!
  bgg_id: String
  notes: String
}

input GameCreateManyWithoutOwnerInput {
  create: [GameCreateWithoutOwnerInput!]
  connect: [GameWhereUniqueInput!]
}

input GameCreateOneWithoutSessionsInput {
  create: GameCreateWithoutSessionsInput
  connect: GameWhereUniqueInput
}

input GameCreateWithoutOwnerInput {
  id: ID
  sessions: SessionCreateManyWithoutGameInput
  name: String!
  bgg_id: String
  notes: String
}

input GameCreateWithoutSessionsInput {
  id: ID
  owner: UserCreateOneWithoutGamesInput
  name: String!
  bgg_id: String
  notes: String
}

type GameEdge {
  node: Game!
  cursor: String!
}

enum GameOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  bgg_id_ASC
  bgg_id_DESC
  notes_ASC
  notes_DESC
}

type GamePreviousValues {
  id: ID!
  name: String!
  bgg_id: String
  notes: String
}

input GameScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  bgg_id: String
  bgg_id_not: String
  bgg_id_in: [String!]
  bgg_id_not_in: [String!]
  bgg_id_lt: String
  bgg_id_lte: String
  bgg_id_gt: String
  bgg_id_gte: String
  bgg_id_contains: String
  bgg_id_not_contains: String
  bgg_id_starts_with: String
  bgg_id_not_starts_with: String
  bgg_id_ends_with: String
  bgg_id_not_ends_with: String
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  AND: [GameScalarWhereInput!]
  OR: [GameScalarWhereInput!]
  NOT: [GameScalarWhereInput!]
}

type GameSubscriptionPayload {
  mutation: MutationType!
  node: Game
  updatedFields: [String!]
  previousValues: GamePreviousValues
}

input GameSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GameWhereInput
  AND: [GameSubscriptionWhereInput!]
  OR: [GameSubscriptionWhereInput!]
  NOT: [GameSubscriptionWhereInput!]
}

input GameUpdateInput {
  owner: UserUpdateOneWithoutGamesInput
  sessions: SessionUpdateManyWithoutGameInput
  name: String
  bgg_id: String
  notes: String
}

input GameUpdateManyDataInput {
  name: String
  bgg_id: String
  notes: String
}

input GameUpdateManyMutationInput {
  name: String
  bgg_id: String
  notes: String
}

input GameUpdateManyWithoutOwnerInput {
  create: [GameCreateWithoutOwnerInput!]
  delete: [GameWhereUniqueInput!]
  connect: [GameWhereUniqueInput!]
  set: [GameWhereUniqueInput!]
  disconnect: [GameWhereUniqueInput!]
  update: [GameUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [GameUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [GameScalarWhereInput!]
  updateMany: [GameUpdateManyWithWhereNestedInput!]
}

input GameUpdateManyWithWhereNestedInput {
  where: GameScalarWhereInput!
  data: GameUpdateManyDataInput!
}

input GameUpdateOneRequiredWithoutSessionsInput {
  create: GameCreateWithoutSessionsInput
  update: GameUpdateWithoutSessionsDataInput
  upsert: GameUpsertWithoutSessionsInput
  connect: GameWhereUniqueInput
}

input GameUpdateWithoutOwnerDataInput {
  sessions: SessionUpdateManyWithoutGameInput
  name: String
  bgg_id: String
  notes: String
}

input GameUpdateWithoutSessionsDataInput {
  owner: UserUpdateOneWithoutGamesInput
  name: String
  bgg_id: String
  notes: String
}

input GameUpdateWithWhereUniqueWithoutOwnerInput {
  where: GameWhereUniqueInput!
  data: GameUpdateWithoutOwnerDataInput!
}

input GameUpsertWithoutSessionsInput {
  update: GameUpdateWithoutSessionsDataInput!
  create: GameCreateWithoutSessionsInput!
}

input GameUpsertWithWhereUniqueWithoutOwnerInput {
  where: GameWhereUniqueInput!
  update: GameUpdateWithoutOwnerDataInput!
  create: GameCreateWithoutOwnerInput!
}

input GameWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  owner: UserWhereInput
  sessions_every: SessionWhereInput
  sessions_some: SessionWhereInput
  sessions_none: SessionWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  bgg_id: String
  bgg_id_not: String
  bgg_id_in: [String!]
  bgg_id_not_in: [String!]
  bgg_id_lt: String
  bgg_id_lte: String
  bgg_id_gt: String
  bgg_id_gte: String
  bgg_id_contains: String
  bgg_id_not_contains: String
  bgg_id_starts_with: String
  bgg_id_not_starts_with: String
  bgg_id_ends_with: String
  bgg_id_not_ends_with: String
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  AND: [GameWhereInput!]
  OR: [GameWhereInput!]
  NOT: [GameWhereInput!]
}

input GameWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createGame(data: GameCreateInput!): Game!
  updateGame(data: GameUpdateInput!, where: GameWhereUniqueInput!): Game
  updateManyGames(data: GameUpdateManyMutationInput!, where: GameWhereInput): BatchPayload!
  upsertGame(where: GameWhereUniqueInput!, create: GameCreateInput!, update: GameUpdateInput!): Game!
  deleteGame(where: GameWhereUniqueInput!): Game
  deleteManyGames(where: GameWhereInput): BatchPayload!
  createPlayer(data: PlayerCreateInput!): Player!
  updatePlayer(data: PlayerUpdateInput!, where: PlayerWhereUniqueInput!): Player
  updateManyPlayers(data: PlayerUpdateManyMutationInput!, where: PlayerWhereInput): BatchPayload!
  upsertPlayer(where: PlayerWhereUniqueInput!, create: PlayerCreateInput!, update: PlayerUpdateInput!): Player!
  deletePlayer(where: PlayerWhereUniqueInput!): Player
  deleteManyPlayers(where: PlayerWhereInput): BatchPayload!
  createScore(data: ScoreCreateInput!): Score!
  updateScore(data: ScoreUpdateInput!, where: ScoreWhereUniqueInput!): Score
  updateManyScores(data: ScoreUpdateManyMutationInput!, where: ScoreWhereInput): BatchPayload!
  upsertScore(where: ScoreWhereUniqueInput!, create: ScoreCreateInput!, update: ScoreUpdateInput!): Score!
  deleteScore(where: ScoreWhereUniqueInput!): Score
  deleteManyScores(where: ScoreWhereInput): BatchPayload!
  createSession(data: SessionCreateInput!): Session!
  updateSession(data: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session
  updateManySessions(data: SessionUpdateManyMutationInput!, where: SessionWhereInput): BatchPayload!
  upsertSession(where: SessionWhereUniqueInput!, create: SessionCreateInput!, update: SessionUpdateInput!): Session!
  deleteSession(where: SessionWhereUniqueInput!): Session
  deleteManySessions(where: SessionWhereInput): BatchPayload!
  createTournament(data: TournamentCreateInput!): Tournament!
  updateTournament(data: TournamentUpdateInput!, where: TournamentWhereUniqueInput!): Tournament
  updateManyTournaments(data: TournamentUpdateManyMutationInput!, where: TournamentWhereInput): BatchPayload!
  upsertTournament(where: TournamentWhereUniqueInput!, create: TournamentCreateInput!, update: TournamentUpdateInput!): Tournament!
  deleteTournament(where: TournamentWhereUniqueInput!): Tournament
  deleteManyTournaments(where: TournamentWhereInput): BatchPayload!
  createTournamentPlayer(data: TournamentPlayerCreateInput!): TournamentPlayer!
  updateTournamentPlayer(data: TournamentPlayerUpdateInput!, where: TournamentPlayerWhereUniqueInput!): TournamentPlayer
  updateManyTournamentPlayers(data: TournamentPlayerUpdateManyMutationInput!, where: TournamentPlayerWhereInput): BatchPayload!
  upsertTournamentPlayer(where: TournamentPlayerWhereUniqueInput!, create: TournamentPlayerCreateInput!, update: TournamentPlayerUpdateInput!): TournamentPlayer!
  deleteTournamentPlayer(where: TournamentPlayerWhereUniqueInput!): TournamentPlayer
  deleteManyTournamentPlayers(where: TournamentPlayerWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Player {
  id: ID!
  owner: User
  name: String!
  pic: String
  nickname: String
  tournaments(where: TournamentPlayerWhereInput, orderBy: TournamentPlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TournamentPlayer!]
}

type PlayerConnection {
  pageInfo: PageInfo!
  edges: [PlayerEdge]!
  aggregate: AggregatePlayer!
}

input PlayerCreateInput {
  id: ID
  owner: UserCreateOneWithoutPlayersInput
  name: String!
  pic: String
  nickname: String
  tournaments: TournamentPlayerCreateManyWithoutPlayerInput
}

input PlayerCreateManyWithoutOwnerInput {
  create: [PlayerCreateWithoutOwnerInput!]
  connect: [PlayerWhereUniqueInput!]
}

input PlayerCreateOneWithoutTournamentsInput {
  create: PlayerCreateWithoutTournamentsInput
  connect: PlayerWhereUniqueInput
}

input PlayerCreateWithoutOwnerInput {
  id: ID
  name: String!
  pic: String
  nickname: String
  tournaments: TournamentPlayerCreateManyWithoutPlayerInput
}

input PlayerCreateWithoutTournamentsInput {
  id: ID
  owner: UserCreateOneWithoutPlayersInput
  name: String!
  pic: String
  nickname: String
}

type PlayerEdge {
  node: Player!
  cursor: String!
}

enum PlayerOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  pic_ASC
  pic_DESC
  nickname_ASC
  nickname_DESC
}

type PlayerPreviousValues {
  id: ID!
  name: String!
  pic: String
  nickname: String
}

input PlayerScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  pic: String
  pic_not: String
  pic_in: [String!]
  pic_not_in: [String!]
  pic_lt: String
  pic_lte: String
  pic_gt: String
  pic_gte: String
  pic_contains: String
  pic_not_contains: String
  pic_starts_with: String
  pic_not_starts_with: String
  pic_ends_with: String
  pic_not_ends_with: String
  nickname: String
  nickname_not: String
  nickname_in: [String!]
  nickname_not_in: [String!]
  nickname_lt: String
  nickname_lte: String
  nickname_gt: String
  nickname_gte: String
  nickname_contains: String
  nickname_not_contains: String
  nickname_starts_with: String
  nickname_not_starts_with: String
  nickname_ends_with: String
  nickname_not_ends_with: String
  AND: [PlayerScalarWhereInput!]
  OR: [PlayerScalarWhereInput!]
  NOT: [PlayerScalarWhereInput!]
}

type PlayerSubscriptionPayload {
  mutation: MutationType!
  node: Player
  updatedFields: [String!]
  previousValues: PlayerPreviousValues
}

input PlayerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlayerWhereInput
  AND: [PlayerSubscriptionWhereInput!]
  OR: [PlayerSubscriptionWhereInput!]
  NOT: [PlayerSubscriptionWhereInput!]
}

input PlayerUpdateInput {
  owner: UserUpdateOneWithoutPlayersInput
  name: String
  pic: String
  nickname: String
  tournaments: TournamentPlayerUpdateManyWithoutPlayerInput
}

input PlayerUpdateManyDataInput {
  name: String
  pic: String
  nickname: String
}

input PlayerUpdateManyMutationInput {
  name: String
  pic: String
  nickname: String
}

input PlayerUpdateManyWithoutOwnerInput {
  create: [PlayerCreateWithoutOwnerInput!]
  delete: [PlayerWhereUniqueInput!]
  connect: [PlayerWhereUniqueInput!]
  set: [PlayerWhereUniqueInput!]
  disconnect: [PlayerWhereUniqueInput!]
  update: [PlayerUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [PlayerUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [PlayerScalarWhereInput!]
  updateMany: [PlayerUpdateManyWithWhereNestedInput!]
}

input PlayerUpdateManyWithWhereNestedInput {
  where: PlayerScalarWhereInput!
  data: PlayerUpdateManyDataInput!
}

input PlayerUpdateOneRequiredWithoutTournamentsInput {
  create: PlayerCreateWithoutTournamentsInput
  update: PlayerUpdateWithoutTournamentsDataInput
  upsert: PlayerUpsertWithoutTournamentsInput
  connect: PlayerWhereUniqueInput
}

input PlayerUpdateWithoutOwnerDataInput {
  name: String
  pic: String
  nickname: String
  tournaments: TournamentPlayerUpdateManyWithoutPlayerInput
}

input PlayerUpdateWithoutTournamentsDataInput {
  owner: UserUpdateOneWithoutPlayersInput
  name: String
  pic: String
  nickname: String
}

input PlayerUpdateWithWhereUniqueWithoutOwnerInput {
  where: PlayerWhereUniqueInput!
  data: PlayerUpdateWithoutOwnerDataInput!
}

input PlayerUpsertWithoutTournamentsInput {
  update: PlayerUpdateWithoutTournamentsDataInput!
  create: PlayerCreateWithoutTournamentsInput!
}

input PlayerUpsertWithWhereUniqueWithoutOwnerInput {
  where: PlayerWhereUniqueInput!
  update: PlayerUpdateWithoutOwnerDataInput!
  create: PlayerCreateWithoutOwnerInput!
}

input PlayerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  owner: UserWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  pic: String
  pic_not: String
  pic_in: [String!]
  pic_not_in: [String!]
  pic_lt: String
  pic_lte: String
  pic_gt: String
  pic_gte: String
  pic_contains: String
  pic_not_contains: String
  pic_starts_with: String
  pic_not_starts_with: String
  pic_ends_with: String
  pic_not_ends_with: String
  nickname: String
  nickname_not: String
  nickname_in: [String!]
  nickname_not_in: [String!]
  nickname_lt: String
  nickname_lte: String
  nickname_gt: String
  nickname_gte: String
  nickname_contains: String
  nickname_not_contains: String
  nickname_starts_with: String
  nickname_not_starts_with: String
  nickname_ends_with: String
  nickname_not_ends_with: String
  tournaments_every: TournamentPlayerWhereInput
  tournaments_some: TournamentPlayerWhereInput
  tournaments_none: TournamentPlayerWhereInput
  AND: [PlayerWhereInput!]
  OR: [PlayerWhereInput!]
  NOT: [PlayerWhereInput!]
}

input PlayerWhereUniqueInput {
  id: ID
}

type Query {
  game(where: GameWhereUniqueInput!): Game
  games(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Game]!
  gamesConnection(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GameConnection!
  player(where: PlayerWhereUniqueInput!): Player
  players(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Player]!
  playersConnection(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlayerConnection!
  score(where: ScoreWhereUniqueInput!): Score
  scores(where: ScoreWhereInput, orderBy: ScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Score]!
  scoresConnection(where: ScoreWhereInput, orderBy: ScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ScoreConnection!
  session(where: SessionWhereUniqueInput!): Session
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session]!
  sessionsConnection(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SessionConnection!
  tournament(where: TournamentWhereUniqueInput!): Tournament
  tournaments(where: TournamentWhereInput, orderBy: TournamentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tournament]!
  tournamentsConnection(where: TournamentWhereInput, orderBy: TournamentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TournamentConnection!
  tournamentPlayer(where: TournamentPlayerWhereUniqueInput!): TournamentPlayer
  tournamentPlayers(where: TournamentPlayerWhereInput, orderBy: TournamentPlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TournamentPlayer]!
  tournamentPlayersConnection(where: TournamentPlayerWhereInput, orderBy: TournamentPlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TournamentPlayerConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Score {
  id: ID!
  player: TournamentPlayer!
  session: Session!
  score: Int
  notes: String
}

type ScoreConnection {
  pageInfo: PageInfo!
  edges: [ScoreEdge]!
  aggregate: AggregateScore!
}

input ScoreCreateInput {
  id: ID
  player: TournamentPlayerCreateOneWithoutScoresInput!
  session: SessionCreateOneWithoutScoresInput!
  score: Int
  notes: String
}

input ScoreCreateManyWithoutPlayerInput {
  create: [ScoreCreateWithoutPlayerInput!]
  connect: [ScoreWhereUniqueInput!]
}

input ScoreCreateManyWithoutSessionInput {
  create: [ScoreCreateWithoutSessionInput!]
  connect: [ScoreWhereUniqueInput!]
}

input ScoreCreateWithoutPlayerInput {
  id: ID
  session: SessionCreateOneWithoutScoresInput!
  score: Int
  notes: String
}

input ScoreCreateWithoutSessionInput {
  id: ID
  player: TournamentPlayerCreateOneWithoutScoresInput!
  score: Int
  notes: String
}

type ScoreEdge {
  node: Score!
  cursor: String!
}

enum ScoreOrderByInput {
  id_ASC
  id_DESC
  score_ASC
  score_DESC
  notes_ASC
  notes_DESC
}

type ScorePreviousValues {
  id: ID!
  score: Int
  notes: String
}

input ScoreScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  score: Int
  score_not: Int
  score_in: [Int!]
  score_not_in: [Int!]
  score_lt: Int
  score_lte: Int
  score_gt: Int
  score_gte: Int
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  AND: [ScoreScalarWhereInput!]
  OR: [ScoreScalarWhereInput!]
  NOT: [ScoreScalarWhereInput!]
}

type ScoreSubscriptionPayload {
  mutation: MutationType!
  node: Score
  updatedFields: [String!]
  previousValues: ScorePreviousValues
}

input ScoreSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ScoreWhereInput
  AND: [ScoreSubscriptionWhereInput!]
  OR: [ScoreSubscriptionWhereInput!]
  NOT: [ScoreSubscriptionWhereInput!]
}

input ScoreUpdateInput {
  player: TournamentPlayerUpdateOneRequiredWithoutScoresInput
  session: SessionUpdateOneRequiredWithoutScoresInput
  score: Int
  notes: String
}

input ScoreUpdateManyDataInput {
  score: Int
  notes: String
}

input ScoreUpdateManyMutationInput {
  score: Int
  notes: String
}

input ScoreUpdateManyWithoutPlayerInput {
  create: [ScoreCreateWithoutPlayerInput!]
  delete: [ScoreWhereUniqueInput!]
  connect: [ScoreWhereUniqueInput!]
  set: [ScoreWhereUniqueInput!]
  disconnect: [ScoreWhereUniqueInput!]
  update: [ScoreUpdateWithWhereUniqueWithoutPlayerInput!]
  upsert: [ScoreUpsertWithWhereUniqueWithoutPlayerInput!]
  deleteMany: [ScoreScalarWhereInput!]
  updateMany: [ScoreUpdateManyWithWhereNestedInput!]
}

input ScoreUpdateManyWithoutSessionInput {
  create: [ScoreCreateWithoutSessionInput!]
  delete: [ScoreWhereUniqueInput!]
  connect: [ScoreWhereUniqueInput!]
  set: [ScoreWhereUniqueInput!]
  disconnect: [ScoreWhereUniqueInput!]
  update: [ScoreUpdateWithWhereUniqueWithoutSessionInput!]
  upsert: [ScoreUpsertWithWhereUniqueWithoutSessionInput!]
  deleteMany: [ScoreScalarWhereInput!]
  updateMany: [ScoreUpdateManyWithWhereNestedInput!]
}

input ScoreUpdateManyWithWhereNestedInput {
  where: ScoreScalarWhereInput!
  data: ScoreUpdateManyDataInput!
}

input ScoreUpdateWithoutPlayerDataInput {
  session: SessionUpdateOneRequiredWithoutScoresInput
  score: Int
  notes: String
}

input ScoreUpdateWithoutSessionDataInput {
  player: TournamentPlayerUpdateOneRequiredWithoutScoresInput
  score: Int
  notes: String
}

input ScoreUpdateWithWhereUniqueWithoutPlayerInput {
  where: ScoreWhereUniqueInput!
  data: ScoreUpdateWithoutPlayerDataInput!
}

input ScoreUpdateWithWhereUniqueWithoutSessionInput {
  where: ScoreWhereUniqueInput!
  data: ScoreUpdateWithoutSessionDataInput!
}

input ScoreUpsertWithWhereUniqueWithoutPlayerInput {
  where: ScoreWhereUniqueInput!
  update: ScoreUpdateWithoutPlayerDataInput!
  create: ScoreCreateWithoutPlayerInput!
}

input ScoreUpsertWithWhereUniqueWithoutSessionInput {
  where: ScoreWhereUniqueInput!
  update: ScoreUpdateWithoutSessionDataInput!
  create: ScoreCreateWithoutSessionInput!
}

input ScoreWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  player: TournamentPlayerWhereInput
  session: SessionWhereInput
  score: Int
  score_not: Int
  score_in: [Int!]
  score_not_in: [Int!]
  score_lt: Int
  score_lte: Int
  score_gt: Int
  score_gte: Int
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  AND: [ScoreWhereInput!]
  OR: [ScoreWhereInput!]
  NOT: [ScoreWhereInput!]
}

input ScoreWhereUniqueInput {
  id: ID
}

type Session {
  id: ID!
  createdAt: DateTime!
  tournament: Tournament!
  game: Game!
  name: String!
  scores(where: ScoreWhereInput, orderBy: ScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Score!]
}

type SessionConnection {
  pageInfo: PageInfo!
  edges: [SessionEdge]!
  aggregate: AggregateSession!
}

input SessionCreateInput {
  id: ID
  tournament: TournamentCreateOneWithoutSessionsInput!
  game: GameCreateOneWithoutSessionsInput!
  name: String!
  scores: ScoreCreateManyWithoutSessionInput
}

input SessionCreateManyWithoutGameInput {
  create: [SessionCreateWithoutGameInput!]
  connect: [SessionWhereUniqueInput!]
}

input SessionCreateManyWithoutTournamentInput {
  create: [SessionCreateWithoutTournamentInput!]
  connect: [SessionWhereUniqueInput!]
}

input SessionCreateOneWithoutScoresInput {
  create: SessionCreateWithoutScoresInput
  connect: SessionWhereUniqueInput
}

input SessionCreateWithoutGameInput {
  id: ID
  tournament: TournamentCreateOneWithoutSessionsInput!
  name: String!
  scores: ScoreCreateManyWithoutSessionInput
}

input SessionCreateWithoutScoresInput {
  id: ID
  tournament: TournamentCreateOneWithoutSessionsInput!
  game: GameCreateOneWithoutSessionsInput!
  name: String!
}

input SessionCreateWithoutTournamentInput {
  id: ID
  game: GameCreateOneWithoutSessionsInput!
  name: String!
  scores: ScoreCreateManyWithoutSessionInput
}

type SessionEdge {
  node: Session!
  cursor: String!
}

enum SessionOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  name_ASC
  name_DESC
}

type SessionPreviousValues {
  id: ID!
  createdAt: DateTime!
  name: String!
}

input SessionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [SessionScalarWhereInput!]
  OR: [SessionScalarWhereInput!]
  NOT: [SessionScalarWhereInput!]
}

type SessionSubscriptionPayload {
  mutation: MutationType!
  node: Session
  updatedFields: [String!]
  previousValues: SessionPreviousValues
}

input SessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SessionWhereInput
  AND: [SessionSubscriptionWhereInput!]
  OR: [SessionSubscriptionWhereInput!]
  NOT: [SessionSubscriptionWhereInput!]
}

input SessionUpdateInput {
  tournament: TournamentUpdateOneRequiredWithoutSessionsInput
  game: GameUpdateOneRequiredWithoutSessionsInput
  name: String
  scores: ScoreUpdateManyWithoutSessionInput
}

input SessionUpdateManyDataInput {
  name: String
}

input SessionUpdateManyMutationInput {
  name: String
}

input SessionUpdateManyWithoutGameInput {
  create: [SessionCreateWithoutGameInput!]
  delete: [SessionWhereUniqueInput!]
  connect: [SessionWhereUniqueInput!]
  set: [SessionWhereUniqueInput!]
  disconnect: [SessionWhereUniqueInput!]
  update: [SessionUpdateWithWhereUniqueWithoutGameInput!]
  upsert: [SessionUpsertWithWhereUniqueWithoutGameInput!]
  deleteMany: [SessionScalarWhereInput!]
  updateMany: [SessionUpdateManyWithWhereNestedInput!]
}

input SessionUpdateManyWithoutTournamentInput {
  create: [SessionCreateWithoutTournamentInput!]
  delete: [SessionWhereUniqueInput!]
  connect: [SessionWhereUniqueInput!]
  set: [SessionWhereUniqueInput!]
  disconnect: [SessionWhereUniqueInput!]
  update: [SessionUpdateWithWhereUniqueWithoutTournamentInput!]
  upsert: [SessionUpsertWithWhereUniqueWithoutTournamentInput!]
  deleteMany: [SessionScalarWhereInput!]
  updateMany: [SessionUpdateManyWithWhereNestedInput!]
}

input SessionUpdateManyWithWhereNestedInput {
  where: SessionScalarWhereInput!
  data: SessionUpdateManyDataInput!
}

input SessionUpdateOneRequiredWithoutScoresInput {
  create: SessionCreateWithoutScoresInput
  update: SessionUpdateWithoutScoresDataInput
  upsert: SessionUpsertWithoutScoresInput
  connect: SessionWhereUniqueInput
}

input SessionUpdateWithoutGameDataInput {
  tournament: TournamentUpdateOneRequiredWithoutSessionsInput
  name: String
  scores: ScoreUpdateManyWithoutSessionInput
}

input SessionUpdateWithoutScoresDataInput {
  tournament: TournamentUpdateOneRequiredWithoutSessionsInput
  game: GameUpdateOneRequiredWithoutSessionsInput
  name: String
}

input SessionUpdateWithoutTournamentDataInput {
  game: GameUpdateOneRequiredWithoutSessionsInput
  name: String
  scores: ScoreUpdateManyWithoutSessionInput
}

input SessionUpdateWithWhereUniqueWithoutGameInput {
  where: SessionWhereUniqueInput!
  data: SessionUpdateWithoutGameDataInput!
}

input SessionUpdateWithWhereUniqueWithoutTournamentInput {
  where: SessionWhereUniqueInput!
  data: SessionUpdateWithoutTournamentDataInput!
}

input SessionUpsertWithoutScoresInput {
  update: SessionUpdateWithoutScoresDataInput!
  create: SessionCreateWithoutScoresInput!
}

input SessionUpsertWithWhereUniqueWithoutGameInput {
  where: SessionWhereUniqueInput!
  update: SessionUpdateWithoutGameDataInput!
  create: SessionCreateWithoutGameInput!
}

input SessionUpsertWithWhereUniqueWithoutTournamentInput {
  where: SessionWhereUniqueInput!
  update: SessionUpdateWithoutTournamentDataInput!
  create: SessionCreateWithoutTournamentInput!
}

input SessionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  tournament: TournamentWhereInput
  game: GameWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  scores_every: ScoreWhereInput
  scores_some: ScoreWhereInput
  scores_none: ScoreWhereInput
  AND: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
}

input SessionWhereUniqueInput {
  id: ID
}

type Subscription {
  game(where: GameSubscriptionWhereInput): GameSubscriptionPayload
  player(where: PlayerSubscriptionWhereInput): PlayerSubscriptionPayload
  score(where: ScoreSubscriptionWhereInput): ScoreSubscriptionPayload
  session(where: SessionSubscriptionWhereInput): SessionSubscriptionPayload
  tournament(where: TournamentSubscriptionWhereInput): TournamentSubscriptionPayload
  tournamentPlayer(where: TournamentPlayerSubscriptionWhereInput): TournamentPlayerSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Tournament {
  id: ID!
  owner: User
  createdAt: DateTime!
  name: String!
  startDate: DateTime
  endDate: DateTime
  rules: String
  notes: String
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session!]
  players(where: TournamentPlayerWhereInput, orderBy: TournamentPlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TournamentPlayer!]
}

type TournamentConnection {
  pageInfo: PageInfo!
  edges: [TournamentEdge]!
  aggregate: AggregateTournament!
}

input TournamentCreateInput {
  id: ID
  owner: UserCreateOneInput
  name: String!
  startDate: DateTime
  endDate: DateTime
  rules: String
  notes: String
  sessions: SessionCreateManyWithoutTournamentInput
  players: TournamentPlayerCreateManyWithoutTournamentInput
}

input TournamentCreateOneWithoutPlayersInput {
  create: TournamentCreateWithoutPlayersInput
  connect: TournamentWhereUniqueInput
}

input TournamentCreateOneWithoutSessionsInput {
  create: TournamentCreateWithoutSessionsInput
  connect: TournamentWhereUniqueInput
}

input TournamentCreateWithoutPlayersInput {
  id: ID
  owner: UserCreateOneInput
  name: String!
  startDate: DateTime
  endDate: DateTime
  rules: String
  notes: String
  sessions: SessionCreateManyWithoutTournamentInput
}

input TournamentCreateWithoutSessionsInput {
  id: ID
  owner: UserCreateOneInput
  name: String!
  startDate: DateTime
  endDate: DateTime
  rules: String
  notes: String
  players: TournamentPlayerCreateManyWithoutTournamentInput
}

type TournamentEdge {
  node: Tournament!
  cursor: String!
}

enum TournamentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  name_ASC
  name_DESC
  startDate_ASC
  startDate_DESC
  endDate_ASC
  endDate_DESC
  rules_ASC
  rules_DESC
  notes_ASC
  notes_DESC
}

type TournamentPlayer {
  id: ID!
  player: Player!
  tournament: Tournament!
  role: String
  nickname: String
  scores(where: ScoreWhereInput, orderBy: ScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Score!]
}

type TournamentPlayerConnection {
  pageInfo: PageInfo!
  edges: [TournamentPlayerEdge]!
  aggregate: AggregateTournamentPlayer!
}

input TournamentPlayerCreateInput {
  id: ID
  player: PlayerCreateOneWithoutTournamentsInput!
  tournament: TournamentCreateOneWithoutPlayersInput!
  role: String
  nickname: String
  scores: ScoreCreateManyWithoutPlayerInput
}

input TournamentPlayerCreateManyWithoutPlayerInput {
  create: [TournamentPlayerCreateWithoutPlayerInput!]
  connect: [TournamentPlayerWhereUniqueInput!]
}

input TournamentPlayerCreateManyWithoutTournamentInput {
  create: [TournamentPlayerCreateWithoutTournamentInput!]
  connect: [TournamentPlayerWhereUniqueInput!]
}

input TournamentPlayerCreateOneWithoutScoresInput {
  create: TournamentPlayerCreateWithoutScoresInput
  connect: TournamentPlayerWhereUniqueInput
}

input TournamentPlayerCreateWithoutPlayerInput {
  id: ID
  tournament: TournamentCreateOneWithoutPlayersInput!
  role: String
  nickname: String
  scores: ScoreCreateManyWithoutPlayerInput
}

input TournamentPlayerCreateWithoutScoresInput {
  id: ID
  player: PlayerCreateOneWithoutTournamentsInput!
  tournament: TournamentCreateOneWithoutPlayersInput!
  role: String
  nickname: String
}

input TournamentPlayerCreateWithoutTournamentInput {
  id: ID
  player: PlayerCreateOneWithoutTournamentsInput!
  role: String
  nickname: String
  scores: ScoreCreateManyWithoutPlayerInput
}

type TournamentPlayerEdge {
  node: TournamentPlayer!
  cursor: String!
}

enum TournamentPlayerOrderByInput {
  id_ASC
  id_DESC
  role_ASC
  role_DESC
  nickname_ASC
  nickname_DESC
}

type TournamentPlayerPreviousValues {
  id: ID!
  role: String
  nickname: String
}

input TournamentPlayerScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  role: String
  role_not: String
  role_in: [String!]
  role_not_in: [String!]
  role_lt: String
  role_lte: String
  role_gt: String
  role_gte: String
  role_contains: String
  role_not_contains: String
  role_starts_with: String
  role_not_starts_with: String
  role_ends_with: String
  role_not_ends_with: String
  nickname: String
  nickname_not: String
  nickname_in: [String!]
  nickname_not_in: [String!]
  nickname_lt: String
  nickname_lte: String
  nickname_gt: String
  nickname_gte: String
  nickname_contains: String
  nickname_not_contains: String
  nickname_starts_with: String
  nickname_not_starts_with: String
  nickname_ends_with: String
  nickname_not_ends_with: String
  AND: [TournamentPlayerScalarWhereInput!]
  OR: [TournamentPlayerScalarWhereInput!]
  NOT: [TournamentPlayerScalarWhereInput!]
}

type TournamentPlayerSubscriptionPayload {
  mutation: MutationType!
  node: TournamentPlayer
  updatedFields: [String!]
  previousValues: TournamentPlayerPreviousValues
}

input TournamentPlayerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TournamentPlayerWhereInput
  AND: [TournamentPlayerSubscriptionWhereInput!]
  OR: [TournamentPlayerSubscriptionWhereInput!]
  NOT: [TournamentPlayerSubscriptionWhereInput!]
}

input TournamentPlayerUpdateInput {
  player: PlayerUpdateOneRequiredWithoutTournamentsInput
  tournament: TournamentUpdateOneRequiredWithoutPlayersInput
  role: String
  nickname: String
  scores: ScoreUpdateManyWithoutPlayerInput
}

input TournamentPlayerUpdateManyDataInput {
  role: String
  nickname: String
}

input TournamentPlayerUpdateManyMutationInput {
  role: String
  nickname: String
}

input TournamentPlayerUpdateManyWithoutPlayerInput {
  create: [TournamentPlayerCreateWithoutPlayerInput!]
  delete: [TournamentPlayerWhereUniqueInput!]
  connect: [TournamentPlayerWhereUniqueInput!]
  set: [TournamentPlayerWhereUniqueInput!]
  disconnect: [TournamentPlayerWhereUniqueInput!]
  update: [TournamentPlayerUpdateWithWhereUniqueWithoutPlayerInput!]
  upsert: [TournamentPlayerUpsertWithWhereUniqueWithoutPlayerInput!]
  deleteMany: [TournamentPlayerScalarWhereInput!]
  updateMany: [TournamentPlayerUpdateManyWithWhereNestedInput!]
}

input TournamentPlayerUpdateManyWithoutTournamentInput {
  create: [TournamentPlayerCreateWithoutTournamentInput!]
  delete: [TournamentPlayerWhereUniqueInput!]
  connect: [TournamentPlayerWhereUniqueInput!]
  set: [TournamentPlayerWhereUniqueInput!]
  disconnect: [TournamentPlayerWhereUniqueInput!]
  update: [TournamentPlayerUpdateWithWhereUniqueWithoutTournamentInput!]
  upsert: [TournamentPlayerUpsertWithWhereUniqueWithoutTournamentInput!]
  deleteMany: [TournamentPlayerScalarWhereInput!]
  updateMany: [TournamentPlayerUpdateManyWithWhereNestedInput!]
}

input TournamentPlayerUpdateManyWithWhereNestedInput {
  where: TournamentPlayerScalarWhereInput!
  data: TournamentPlayerUpdateManyDataInput!
}

input TournamentPlayerUpdateOneRequiredWithoutScoresInput {
  create: TournamentPlayerCreateWithoutScoresInput
  update: TournamentPlayerUpdateWithoutScoresDataInput
  upsert: TournamentPlayerUpsertWithoutScoresInput
  connect: TournamentPlayerWhereUniqueInput
}

input TournamentPlayerUpdateWithoutPlayerDataInput {
  tournament: TournamentUpdateOneRequiredWithoutPlayersInput
  role: String
  nickname: String
  scores: ScoreUpdateManyWithoutPlayerInput
}

input TournamentPlayerUpdateWithoutScoresDataInput {
  player: PlayerUpdateOneRequiredWithoutTournamentsInput
  tournament: TournamentUpdateOneRequiredWithoutPlayersInput
  role: String
  nickname: String
}

input TournamentPlayerUpdateWithoutTournamentDataInput {
  player: PlayerUpdateOneRequiredWithoutTournamentsInput
  role: String
  nickname: String
  scores: ScoreUpdateManyWithoutPlayerInput
}

input TournamentPlayerUpdateWithWhereUniqueWithoutPlayerInput {
  where: TournamentPlayerWhereUniqueInput!
  data: TournamentPlayerUpdateWithoutPlayerDataInput!
}

input TournamentPlayerUpdateWithWhereUniqueWithoutTournamentInput {
  where: TournamentPlayerWhereUniqueInput!
  data: TournamentPlayerUpdateWithoutTournamentDataInput!
}

input TournamentPlayerUpsertWithoutScoresInput {
  update: TournamentPlayerUpdateWithoutScoresDataInput!
  create: TournamentPlayerCreateWithoutScoresInput!
}

input TournamentPlayerUpsertWithWhereUniqueWithoutPlayerInput {
  where: TournamentPlayerWhereUniqueInput!
  update: TournamentPlayerUpdateWithoutPlayerDataInput!
  create: TournamentPlayerCreateWithoutPlayerInput!
}

input TournamentPlayerUpsertWithWhereUniqueWithoutTournamentInput {
  where: TournamentPlayerWhereUniqueInput!
  update: TournamentPlayerUpdateWithoutTournamentDataInput!
  create: TournamentPlayerCreateWithoutTournamentInput!
}

input TournamentPlayerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  player: PlayerWhereInput
  tournament: TournamentWhereInput
  role: String
  role_not: String
  role_in: [String!]
  role_not_in: [String!]
  role_lt: String
  role_lte: String
  role_gt: String
  role_gte: String
  role_contains: String
  role_not_contains: String
  role_starts_with: String
  role_not_starts_with: String
  role_ends_with: String
  role_not_ends_with: String
  nickname: String
  nickname_not: String
  nickname_in: [String!]
  nickname_not_in: [String!]
  nickname_lt: String
  nickname_lte: String
  nickname_gt: String
  nickname_gte: String
  nickname_contains: String
  nickname_not_contains: String
  nickname_starts_with: String
  nickname_not_starts_with: String
  nickname_ends_with: String
  nickname_not_ends_with: String
  scores_every: ScoreWhereInput
  scores_some: ScoreWhereInput
  scores_none: ScoreWhereInput
  AND: [TournamentPlayerWhereInput!]
  OR: [TournamentPlayerWhereInput!]
  NOT: [TournamentPlayerWhereInput!]
}

input TournamentPlayerWhereUniqueInput {
  id: ID
}

type TournamentPreviousValues {
  id: ID!
  createdAt: DateTime!
  name: String!
  startDate: DateTime
  endDate: DateTime
  rules: String
  notes: String
}

type TournamentSubscriptionPayload {
  mutation: MutationType!
  node: Tournament
  updatedFields: [String!]
  previousValues: TournamentPreviousValues
}

input TournamentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TournamentWhereInput
  AND: [TournamentSubscriptionWhereInput!]
  OR: [TournamentSubscriptionWhereInput!]
  NOT: [TournamentSubscriptionWhereInput!]
}

input TournamentUpdateInput {
  owner: UserUpdateOneInput
  name: String
  startDate: DateTime
  endDate: DateTime
  rules: String
  notes: String
  sessions: SessionUpdateManyWithoutTournamentInput
  players: TournamentPlayerUpdateManyWithoutTournamentInput
}

input TournamentUpdateManyMutationInput {
  name: String
  startDate: DateTime
  endDate: DateTime
  rules: String
  notes: String
}

input TournamentUpdateOneRequiredWithoutPlayersInput {
  create: TournamentCreateWithoutPlayersInput
  update: TournamentUpdateWithoutPlayersDataInput
  upsert: TournamentUpsertWithoutPlayersInput
  connect: TournamentWhereUniqueInput
}

input TournamentUpdateOneRequiredWithoutSessionsInput {
  create: TournamentCreateWithoutSessionsInput
  update: TournamentUpdateWithoutSessionsDataInput
  upsert: TournamentUpsertWithoutSessionsInput
  connect: TournamentWhereUniqueInput
}

input TournamentUpdateWithoutPlayersDataInput {
  owner: UserUpdateOneInput
  name: String
  startDate: DateTime
  endDate: DateTime
  rules: String
  notes: String
  sessions: SessionUpdateManyWithoutTournamentInput
}

input TournamentUpdateWithoutSessionsDataInput {
  owner: UserUpdateOneInput
  name: String
  startDate: DateTime
  endDate: DateTime
  rules: String
  notes: String
  players: TournamentPlayerUpdateManyWithoutTournamentInput
}

input TournamentUpsertWithoutPlayersInput {
  update: TournamentUpdateWithoutPlayersDataInput!
  create: TournamentCreateWithoutPlayersInput!
}

input TournamentUpsertWithoutSessionsInput {
  update: TournamentUpdateWithoutSessionsDataInput!
  create: TournamentCreateWithoutSessionsInput!
}

input TournamentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  owner: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  rules: String
  rules_not: String
  rules_in: [String!]
  rules_not_in: [String!]
  rules_lt: String
  rules_lte: String
  rules_gt: String
  rules_gte: String
  rules_contains: String
  rules_not_contains: String
  rules_starts_with: String
  rules_not_starts_with: String
  rules_ends_with: String
  rules_not_ends_with: String
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  sessions_every: SessionWhereInput
  sessions_some: SessionWhereInput
  sessions_none: SessionWhereInput
  players_every: TournamentPlayerWhereInput
  players_some: TournamentPlayerWhereInput
  players_none: TournamentPlayerWhereInput
  AND: [TournamentWhereInput!]
  OR: [TournamentWhereInput!]
  NOT: [TournamentWhereInput!]
}

input TournamentWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  username: String!
  email: String!
  password: String!
  players(where: PlayerWhereInput, orderBy: PlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Player!]
  games(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Game!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  username: String!
  email: String!
  password: String!
  players: PlayerCreateManyWithoutOwnerInput
  games: GameCreateManyWithoutOwnerInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutGamesInput {
  create: UserCreateWithoutGamesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPlayersInput {
  create: UserCreateWithoutPlayersInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutGamesInput {
  id: ID
  username: String!
  email: String!
  password: String!
  players: PlayerCreateManyWithoutOwnerInput
}

input UserCreateWithoutPlayersInput {
  id: ID
  username: String!
  email: String!
  password: String!
  games: GameCreateManyWithoutOwnerInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  username_ASC
  username_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
}

type UserPreviousValues {
  id: ID!
  username: String!
  email: String!
  password: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  username: String
  email: String
  password: String
  players: PlayerUpdateManyWithoutOwnerInput
  games: GameUpdateManyWithoutOwnerInput
}

input UserUpdateInput {
  username: String
  email: String
  password: String
  players: PlayerUpdateManyWithoutOwnerInput
  games: GameUpdateManyWithoutOwnerInput
}

input UserUpdateManyMutationInput {
  username: String
  email: String
  password: String
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutGamesInput {
  create: UserCreateWithoutGamesInput
  update: UserUpdateWithoutGamesDataInput
  upsert: UserUpsertWithoutGamesInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutPlayersInput {
  create: UserCreateWithoutPlayersInput
  update: UserUpdateWithoutPlayersDataInput
  upsert: UserUpsertWithoutPlayersInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutGamesDataInput {
  username: String
  email: String
  password: String
  players: PlayerUpdateManyWithoutOwnerInput
}

input UserUpdateWithoutPlayersDataInput {
  username: String
  email: String
  password: String
  games: GameUpdateManyWithoutOwnerInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutGamesInput {
  update: UserUpdateWithoutGamesDataInput!
  create: UserCreateWithoutGamesInput!
}

input UserUpsertWithoutPlayersInput {
  update: UserUpdateWithoutPlayersDataInput!
  create: UserCreateWithoutPlayersInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  players_every: PlayerWhereInput
  players_some: PlayerWhereInput
  players_none: PlayerWhereInput
  games_every: GameWhereInput
  games_some: GameWhereInput
  games_none: GameWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  username: String
  email: String
}
`